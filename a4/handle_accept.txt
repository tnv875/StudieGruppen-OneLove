# TODO: Handle Accept
    def handle_Accept(self, accept: str):
        """
        Method to handle accept in header. Assumes an accept header is present in the file
        """

        # From docs:
        '''
        If an Accept header field is present,
        and if the server cannot send a response which is acceptable
        according to the combined Accept field value, then the server SHOULD
        send a 406 (not acceptable) response.'''

        # IF URL end with a dash, this is handled another place
        if self.url[-1] == "\\":
            return

        types = accept.split(sep= ", ")

        types_dict = {}
        for type_ in types:
            try:
                if ";" in type_:
                    key, value = type_.split(sep=";", maxsplit=1)
                    variable, value = value.split(sep="=", maxsplit=1)
                    types_dict.update({key: value})
                else:
                    types_dict.update({type_: "1.1"})
            except:
                next

        types_subtypes = {"*": "*", "image": ["jpeg", "jpg", "png", "svg+xml"], "text": ["html", "plain", "csv", "css"], "application": ["xhtml+xml", "xml"]}
        accepted_list = []
        for type_subtype in types_dict.keys():
            MIME_type, MIME_subtype = type_subtype.split(sep="/")
            if MIME_type in types_subtypes:
                if MIME_subtype in types_subtypes[MIME_type] or MIME_type == "*":
                    #Make a list of all matches --> Sorted List
                    accepted_list.append(MIME_type+"/"+MIME_subtype)
                else:
                    next
            else:
                next
        if accepted_list == []:
            self.status = 406
            self.handle_error()
        else:
            final_dict = {}
            for elem in accepted_list:
                value = types_dict[elem]
                final_dict.update({elem: value})
            sorted_final_list_tuples = sorted(final_dict.items(), key= lambda x:x[1], reverse=True)
            
            # Search for file ending in sorted order from URL and self 
            for best_option in sorted_final_list_tuples:
                if best_option[0].split(sep="/")[1] =="*":
                    if best_option[0].split(sep="/")[0] == "*":
                        for type in types_subtypes:
                            for elem in	types_subtypes[type]:
                                if os.path.exists(self.url + "." + elem):
                                    MIME_type = best_option[0].split(sep="/")[0]
                                    MIME_subtype = best_option[0].split(sep="/")[1]
                                    self.response_headers.append(f"Content-Type: {MIME_type}/{MIME_subtype}")
                                    self.url = self.url + "." + elem
                                    return
                    else:
                        for elem in	types_subtypes[best_option[0].split(sep="/")[0]]:
                            if os.path.exists(self.url + "." + elem):
                                MIME_type = best_option[0].split(sep="/")[0]
                                MIME_subtype = best_option[0].split(sep="/")[1]
                                self.response_headers.append(f"Content-Type: {MIME_type}/{MIME_subtype}")
                                self.url = self.url + "." + best_option[0].split(sep="/")[1]
                                return		
                elif os.path.exists(self.url + "." + best_option[0].split(sep="/")[1]):
                    MIME_type = best_option[0].split(sep="/")[0]
                    MIME_subtype = best_option[0].split(sep="/")[1]
                    self.response_headers.append(f"Content-Type: {MIME_type}/{MIME_subtype}")
                    self.url = self.url + "." + best_option[0].split(sep="/")[1]
                    return
                else:
                    next